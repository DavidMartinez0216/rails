require 'uri'
require 'active_support/core_ext/hash/indifferent_access'
require 'action_controller/metal/exceptions'

module ActionDispatch
  module Assertions
    # Suite of assertions to test routes generated by \Rails and the handling of requests made to them.
    module RoutingAssertions
      # Asserts that the routing of the given +path+ was handled correctly and that the parsed options (given in the +expected_options+ hash)
      # match +path+. Basically, it asserts that \Rails recognizes the route given by +expected_options+.
      #
      # Pass a hash in the second argument (+path+) to specify the request method. This is useful for routes
      # requiring a specific HTTP method. The hash should contain a :path with the incoming request path
      # and a :method containing the required HTTP verb.
      #
      #   # assert that POSTing to /items will call the create action on ItemsController
      #   assert_recognizes({controller: 'items', action: 'create'}, {path: 'items', method: :post})
      #
      # You can also pass in +extras+ with a hash containing URL parameters that would normally be in the query string. This can be used
      # to assert that values in the query string string will end up in the params hash correctly. To test query strings you must use the
      # extras argument, appending the query string on the path directly will not work. For example:
      #
      #   # assert that a path of '/items/list/1?view=print' returns the correct options
      #   assert_recognizes({controller: 'items', action: 'list', id: '1', view: 'print'}, 'items/list/1', { view: "print" })
      #
      # The +message+ parameter allows you to pass in an error message that is displayed upon failure.
      #
      #   # Check the default route (i.e., the index action)
      #   assert_recognizes({controller: 'items', action: 'index'}, 'items')
      #
      #   # Test a specific action
      #   assert_recognizes({controller: 'items', action: 'list'}, 'items/list')
      #
      #   # Test an action with a parameter
      #   assert_recognizes({controller: 'items', action: 'destroy', id: '1'}, 'items/destroy/1')
      #
      #   # Test a custom route
      #   assert_recognizes({controller: 'items', action: 'show', id: '1'}, 'view/item1')
      def assert_recognizes(expected_options, path, extras={}, msg=nil)
        path = normalize_path(path, extras) 
        assert_not_redirects(path, extras, msg)

        request = recognized_request_for(path)

        expected_options = expected_options.clone

        expected_options.stringify_keys!

        msg = message(msg, "") {
          sprintf("The recognized options <%s> did not match <%s>, difference:",
                  request.path_parameters, expected_options)
        }

        assert_equal(expected_options, request.path_parameters, msg)
      end

      # Asserts that the provided options can be used to generate the provided path. This is the inverse of +assert_recognizes+.
      # The +extras+ parameter is used to tell the request the names and values of additional request parameters that would be in
      # a query string. The +message+ parameter allows you to specify a custom error message for assertion failures.
      #
      # The +defaults+ parameter is unused.
      #
      #   # Asserts that the default action is generated for a route with no action
      #   assert_generates "/items", controller: "items", action: "index"
      #
      #   # Tests that the list action is properly routed
      #   assert_generates "/items/list", controller: "items", action: "list"
      #
      #   # Tests the generation of a route with a parameter
      #   assert_generates "/items/list/1", { controller: "items", action: "list", id: "1" }
      #
      #   # Asserts that the generated route gives us our custom route
      #   assert_generates "changesets/12", { controller: 'scm', action: 'show_diff', revision: "12" }
      def assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)
        if expected_path =~ %r{://}
          fail_on(URI::InvalidURIError) do
            uri = URI.parse(expected_path)
            expected_path = uri.path.to_s.empty? ? "/" : uri.path
          end
        else
          expected_path = "/#{expected_path}" unless expected_path.first == '/'
        end
        # Load routes.rb if it hasn't been loaded.

        generated_path, extra_keys = @routes.generate_extras(options, defaults)
        generated_path = {
          path:     generated_path,
          protocol: options[:protocol]
        }
        found_extras = options.reject {|k, v| (! extra_keys.include? k) || (generated_path.include? k) }

        assert_not_redirects(generated_path, found_extras, message)

        msg = message || sprintf("found extras <%s>, not <%s>", found_extras, extras)
        assert_equal(extras, found_extras, msg)

        msg = message || sprintf("The generated path <%s> did not match <%s>", generated_path,
            expected_path)
        assert_equal(expected_path, generated_path[:path], msg)
      end

      # Asserts that path and options match both ways; in other words, it verifies that <tt>path</tt> generates
      # <tt>options</tt> and then that <tt>options</tt> generates <tt>path</tt>. This essentially combines +assert_recognizes+
      # and +assert_generates+ into one step.
      #
      # The +extras+ hash allows you to specify options that would normally be provided as a query string to the action. The
      # +message+ parameter allows you to specify a custom error message to display upon failure.
      #
      #  # Assert a basic route: a controller with the default action (index)
      #  assert_routing '/home', controller: 'home', action: 'index'
      #
      #  # Test a route generated with a specific controller, action, and parameter (id)
      #  assert_routing '/entries/show/23', controller: 'entries', action: 'show', id: 23
      #
      #  # Assert a basic route (controller + default action), with an error message if it fails
      #  assert_routing '/store', { controller: 'store', action: 'index' }, {}, {}, 'Route for store index not generated properly'
      #
      #  # Tests a route, providing a defaults hash
      #  assert_routing 'controller/action/9', {id: "9", item: "square"}, {controller: "controller", action: "action"}, {}, {item: "square"}
      #
      #  # Tests a route with a HTTP method
      #  assert_routing({ method: 'put', path: '/product/321' }, { controller: "product", action: "update", id: "321" })
      def assert_routing(path, options, defaults={}, extras={}, message=nil)
        assert_recognizes(options, path, extras, message)

        controller, default_controller = options[:controller], defaults[:controller]
        if controller && controller.include?(?/) && default_controller && default_controller.include?(?/)
          options[:controller] = "/#{controller}"
        end

        normalized_path = normalize_path(path)
        options[:protocol] ||= "https://" if normalized_path[:protocol] == "https://"

        generate_options = options.dup.delete_if{ |k,v| defaults.key?(k) }

        assert_generates(path.is_a?(Hash) ? path[:path] : path, generate_options, defaults, extras, message)
      end

      # Asserts that the redirect of the given +path+ was handled correctly and that the redirected url matches the +expected_url+ string.
      #
      #   # assert that a path of '/google' redirects to https://google.com/
      #   assert_redirects "https://google.com/", "/google"
      #
      # You can pass in +extras+ with a hash containing URL parameters that would normally be in the query string.
      #
      #   # assert that a path of '/out?to=https://google.com/' redirects to https://google.com/
      #   assert_redirects "https://google.com/", "/out", { to: "https://google.com/" }
      #
      # The +status+ parameter allows you to pass in the expected HTTP response status code.
      #
      # The +message+ parameter allows you to pass in an error message that is displayed upon failure.
      def assert_redirects(expected_url, path, extras={}, status=301, message=nil)
        normalized_path = normalize_path(path, extras)
        actual_status, headers, body = recognize_path(normalized_path)

        msg = message || sprintf("The path <%s> was a route to <%s>", path, actual_status)
        assert((300..399).to_a.include?(actual_status), msg) 

        msg = message || sprintf("The path <%s> did not redirect to <%s>",
            path, expected_url)
        assert_equal(expected_url, headers["Location"], msg)

        msg = message || sprintf("The redirect status <%s> did not match the expected status <%s>",
            actual_status, status)
        assert_equal(status, actual_status, msg)
      end

      # Asserts that the given +path+ was handled and is not redirected.
      #
      #   # Asserts that a path of '/home/index' does not redirect
      #   assert_not_redirects "/home/index"
      #
      # You can pass in +extras+ with a hash containing URL parameters that would normally be in the query string.
      #
      # The +message+ parameter allows you to pass in an error message that is displayed upon failure.
      def assert_not_redirects(path, extras={}, message=nil)
        normalized_path = normalize_path(path, extras)
        recognized_path = recognize_path(normalized_path)
        if Array === recognized_path
          status, headers, body = recognized_path
          response = Rack::Response.new(body, status, headers)
          message ||= sprintf("The recognized path <%s> redirected to <%s>",
              path, headers['Location'])
          assert(!response.redirect?, message)
        end
      end

      # A helper to make it easier to test different route configurations.
      # This method temporarily replaces @routes
      # with a new RouteSet instance.
      #
      # The new instance is yielded to the passed block. Typically the block
      # will create some routes using <tt>set.draw { match ... }</tt>:
      #
      #   with_routing do |set|
      #     set.draw do
      #       resources :users
      #     end
      #     assert_equal "/users", users_path
      #   end
      #
      def with_routing
        old_routes, @routes = @routes, ActionDispatch::Routing::RouteSet.new
        if defined?(@controller) && @controller
          old_controller, @controller = @controller, @controller.clone
          _routes = @routes

          # Unfortunately, there is currently an abstraction leak between AC::Base
          # and AV::Base which requires having the URL helpers in both AC and AV.
          # To do this safely at runtime for tests, we need to bump up the helper serial
          # to that the old AV subclass isn't cached.
          #
          # TODO: Make this unnecessary
          @controller.singleton_class.send(:include, _routes.url_helpers)
          @controller.view_context_class = Class.new(@controller.view_context_class) do
            include _routes.url_helpers
          end
        end
        yield @routes
      ensure
        @routes = old_routes
        if defined?(@controller) && @controller
          @controller = old_controller
        end
      end

      # ROUTES TODO: These assertions should really work in an integration context
      def method_missing(selector, *args, &block)
        if defined?(@controller) && @controller && @routes && @routes.named_routes.helpers.include?(selector)
          @controller.send(selector, *args, &block)
        else
          super
        end
      end

      private
        # Recognizes the route for a given path.
        def recognized_request_for(path)
          # Assume given controller
          request = ActionController::TestRequest.new

          if path[:path] =~ %r{://}
            fail_on(URI::InvalidURIError) do
              uri = URI.parse(path[:path])
              request.env["rack.url_scheme"] = uri.scheme || "http"
              request.host = uri.host if uri.host
              request.port = uri.port if uri.port
              request.path = uri.path.to_s.empty? ? "/" : uri.path
            end
          else
            request.path = path[:path]
          end

          request.request_method = path[:method] if path[:method]

          params = recognize_path(path)
 
          request.path_parameters = params.with_indifferent_access

          request
        end

        def fail_on(exception_class)
          begin
            yield
          rescue exception_class => e
            raise MiniTest::Assertion, e.message
          end
        end

        def normalize_path(path, extras = {})
          if !path.is_a?(Hash)
            path = {
              method: :get,
              path:   path
            }
          end

          if (path[:path] =~ %r{://}).nil?
            path[:path] = "/#{path[:path]}" unless path[:path].first == "/"
          elsif (path[:path] =~ %r{https://})
            path[:protocol] = "https://"
          end

          path[:extras] = extras

          path
        end

        def recognize_path(path)
          @recognize_path ||= {}
          @recognize_path[hexdigest(path)] ||= fail_on(ActionController::RoutingError) do
            @routes.recognize_path(path[:path], { method: path[:method], protocol: path[:protocol], extras: path[:extras] })
          end
        end

        def hexdigest(path)
          Digest::MD5.hexdigest(path.sort.map(&:to_s).join)
        end
    end
  end
end
